\section{Introduction}\label{introduction}

\section{Compiler Creation}\label{compiler-creation}

\subsection{\texorpdfstring{Scanner.jflex - \emph{Lexical
Analysis}}{Scanner.jflex - Lexical Analysis}}\label{scanner.jflex---lexical-analysis}

Lexical analysis is the first step in the compilation. This is where
source stream code is converted and grouped into tokens
\cite{lexicalAna}. A lexical analyser holds a set of regular expressions
and actions as a specification. The lexical analyser will then create a
program named a lexer, which will read and match an input file against
it's specification.

JFlex is a lexical analyser generator created using the Java language
\cite{JFlexJFl92:online}, used to create the JSON parser in this report.
JFlex uses two constructors Reader and InputStream. This represents
objects in a form that can be lexically analysed. Two examples include a
StringReader which reads input from a String and InputStream which reads
text. The JFlex lexical analyser will then execute a method to assign
tokens, looping through the input file to match against regular
expressions \cite{lexicalAna}.

\emph{alex} Descriptions of systems - Choice for printing (print in
executions or printed in injected Java as she had)

\subsubsection{Macros}\label{macros}

\emph{alex} - \emph{numbers} Choose to allow numbers to have an infinite
number of zeros in front of them - Macros for number inline with the
JSON.org specification for number

\subsubsection{Tokens}\label{tokens}

\emph{Claud Sequence of characters that forms a unit in the grammar of
the programming language} - Dealing with ambiguity - Token choices vs
terminal/ non terminal

\subsection{\texorpdfstring{Parser.cup - \emph{Syntax
Analysis}}{Parser.cup - Syntax Analysis}}\label{parser.cup---syntax-analysis}

\emph{Claud} - Starting symbol - context free grammar

\subsection{Testing}\label{testing}

\emph{alex}

\section{Conclusions}\label{conclusions}
